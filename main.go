package main


import (
  "os"
  "log"
  "bytes"
  "strings"
  "io/ioutil"
  "text/template"
  "github.com/golang/protobuf/proto"
  plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
)

var CODE_HEADER string = `
// Code generated by protoc-gen-grpc-rest-direct. DO NOT EDIT.
package {{.Package}}

import (
	"io"
	"golang.org/x/net/context"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

`

var CODE_SERVICE string = `
// {{.Service}}DirectClient is a shim to connect {{.Service}} client directly server
type {{.Service}}DirectClient struct {
	server {{.Service}}Server
}
 // New{{.Service}}DirectClient creates new {{.Service}}DirectClient
func New{{.Service}}DirectClient(server {{.Service}}Server) *{{.Service}}DirectClient {
	return &{{.Service}}DirectClient{server}
}
`

var CODE_SHIM string = `{{if .StreamOutput}}
//{{.Name}} streaming output shim
type direct{{.Service}}{{.Name}} struct {
  ctx context.Context
  c   chan *{{.OutputType}}
  e   error
}

func (dsm *direct{{.Service}}{{.Name}}) Recv() (*{{.OutputType}}, error) {
	value, ok := <-dsm.c
	if !ok {
    if dsm.e != nil {
      return nil, dsm.e
    }
		return nil, io.EOF
	}
	return value, dsm.e
}
func (dsm *direct{{.Service}}{{.Name}}) Send(a *{{.OutputType}}) error {
	dsm.c <- a
	return nil
}
func (dsm *direct{{.Service}}{{.Name}}) close() {
	close(dsm.c)
}
func (dsm *direct{{.Service}}{{.Name}}) Context() context.Context {
	return dsm.ctx
}
func (dsm *direct{{.Service}}{{.Name}}) CloseSend() error             { return nil }
func (dsm *direct{{.Service}}{{.Name}}) SetTrailer(metadata.MD)       {}
func (dsm *direct{{.Service}}{{.Name}}) SetHeader(metadata.MD) error  { return nil }
func (dsm *direct{{.Service}}{{.Name}}) SendHeader(metadata.MD) error { return nil }
func (dsm *direct{{.Service}}{{.Name}}) SendMsg(m interface{}) error  { return nil }
func (dsm *direct{{.Service}}{{.Name}}) RecvMsg(m interface{}) error  { return nil }
func (dsm *direct{{.Service}}{{.Name}}) Header() (metadata.MD, error) { return nil, nil }
func (dsm *direct{{.Service}}{{.Name}}) Trailer() metadata.MD         { return nil }
func (dir *{{.Service}}DirectClient) {{.Name}}(ctx context.Context, in *{{.InputType}}, opts ...grpc.CallOption) ({{.Service}}_{{.Name}}Client, error) {
	w := &direct{{.Service}}{{.Name}}{ctx, make(chan *{{.OutputType}}, 100), nil}
	go func() {
    defer w.close()
		w.e = dir.server.{{.Name}}(in, w)
	}()
	return w, nil
}
{{else if .StreamInput}}
//{{.Name}} streaming input shim
type direct{{.Service}}{{.Name}} struct {
  ctx context.Context
  c   chan *{{.InputType}}
  out chan *{{.OutputType}}
}

func (dsm *direct{{.Service}}{{.Name}}) Recv() (*{{.InputType}}, error) {
	value, ok := <-dsm.c
	if !ok {
		return nil, io.EOF
	}
	return value, nil
}

func (dsm *direct{{.Service}}{{.Name}}) Send(a *{{.InputType}}) error {
	dsm.c <- a
	return nil
}

func (dsm *direct{{.Service}}{{.Name}}) Context() context.Context {
	return dsm.ctx
}

func (dsm *direct{{.Service}}{{.Name}}) SendAndClose(o *{{.OutputType}}) error {
  dsm.out <- o
  close(dsm.out)
  return nil
}

func (dsm *direct{{.Service}}{{.Name}}) CloseAndRecv() (*{{.OutputType}}, error) {
  close(dsm.c)
  out := <- dsm.out
  return out, nil
}

func (dsm *direct{{.Service}}{{.Name}}) CloseSend() error             { return nil }
func (dsm *direct{{.Service}}{{.Name}}) SetTrailer(metadata.MD)       {}
func (dsm *direct{{.Service}}{{.Name}}) SetHeader(metadata.MD) error  { return nil }
func (dsm *direct{{.Service}}{{.Name}}) SendHeader(metadata.MD) error { return nil }
func (dsm *direct{{.Service}}{{.Name}}) SendMsg(m interface{}) error  { return nil }
func (dsm *direct{{.Service}}{{.Name}}) RecvMsg(m interface{}) error  { return nil }
func (dsm *direct{{.Service}}{{.Name}}) Header() (metadata.MD, error) { return nil, nil }
func (dsm *direct{{.Service}}{{.Name}}) Trailer() metadata.MD         { return nil }

func (dir *{{.Service}}DirectClient) {{.Name}}(ctx context.Context, opts ...grpc.CallOption) ({{.Service}}_{{.Name}}Client, error) {
	w := &direct{{.Service}}{{.Name}}{ctx, make(chan *{{.InputType}}, 100), make(chan *{{.OutputType}}, 3)}
	go func() {
		dir.server.{{.Name}}(w)
	}()
	return w, nil
}
{{else}}
//{{.Name}} shim
func (shim *{{.Service}}DirectClient) {{.Name}}(ctx context.Context, in *{{.InputType}}, opts ...grpc.CallOption) (*{{.OutputType}}, error) {
	return shim.server.{{.Name}}(ctx, in)
}{{end}}
`

func contains(c []string, a string) bool {
  for _, i := range c {
    if a == i {
      return true
    }
  }
  return false
}

type headerDesc struct {
  Package string
}

type serviceDesc struct {
  Service string
}

type methodDesc struct {
  Service string
  Name string
  InputType string
  OutputType string
  StreamOutput bool
  StreamInput bool
}

func cleanProtoType(name string, p string) string {
  if strings.HasPrefix(name, "." + p + ".") {
    return name[len(p) + 2:]
  }
  return name
}

func boolPtrDefaultFalse(b *bool) bool {
  if b == nil {
    return false
  }
  return *b
}

func main() {
	input, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
    log.Printf("failed to read code generator request: %v", err)
		return
	}
	req := new(plugin.CodeGeneratorRequest)
	if err = proto.Unmarshal(input, req); err != nil {
		log.Printf("failed to unmarshal code generator request: %v", err)
    return
	}

  headerTemplate, _ := template.New("header").Parse(CODE_HEADER)
  serviceTemplate, _ := template.New("service").Parse(CODE_SERVICE)
  shimTemplate, err := template.New("shim").Parse(CODE_SHIM)
  if err != nil {
    log.Fatal(err)
  }

  out := []*plugin.CodeGeneratorResponse_File{}
  for _, file := range req.ProtoFile {
    if contains(req.FileToGenerate, *file.Name) {
      //log.Printf("File: %s", *file.Name)
      text := bytes.NewBufferString("")
      headerTemplate.Execute(text, headerDesc{Package:*file.Package})
      for _, service := range file.Service {
        //log.Printf("Service: %s", *service.Name)
        serviceTemplate.Execute(text, serviceDesc{Service:*service.Name})
        for _, method := range service.Method {
          //log.Printf(" method: %s", method)
          err := shimTemplate.Execute(text, methodDesc{
            Service:*service.Name, Name:*method.Name,
            InputType:cleanProtoType(*method.InputType,*file.Package),
            OutputType:cleanProtoType(*method.OutputType,*file.Package),
            StreamOutput:boolPtrDefaultFalse(method.ServerStreaming),
            StreamInput:boolPtrDefaultFalse(method.ClientStreaming),
          })
          if err != nil {
            log.Printf("Error: %s", err)
          }
        }
      }
      n := strings.Replace(*file.Name, ".proto", ".pb.dgw.go", -1)
      t := text.String()
      f := &plugin.CodeGeneratorResponse_File{Name:&n, Content:&t}
      out = append(out, f)
    }
  }

  resp := &plugin.CodeGeneratorResponse{File: out}

  buf, err := proto.Marshal(resp)
	if err != nil {
		log.Fatal(err)
	}
	if _, err := os.Stdout.Write(buf); err != nil {
		log.Fatal(err)
	}

}
